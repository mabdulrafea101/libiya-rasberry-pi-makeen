[
    {
        "id": "tab_control",
        "type": "ui_tab",
        "label": "Control Panel",
        "icon": "dashboard",
        "order": 1
    },
    {
        "id": "tab_history",
        "type": "ui_tab",
        "label": "History",
        "icon": "history",
        "order": 2
    },
    {
        "id": "tab_report",
        "type": "ui_tab",
        "label": "Report",
        "icon": "chart-pie",
        "order": 3
    },
    {
        "id": "group_main",
        "type": "ui_group",
        "name": "Main Control",
        "tab": "tab_control",
        "order": 1,
        "width": "6"
    },
    {
        "id": "group_status",
        "type": "ui_group",
        "name": "System Status",
        "tab": "tab_control",
        "order": 2,
        "width": "6"
    },
    {
        "id": "group_history",
        "type": "ui_group",
        "name": "Recent Scans",
        "tab": "tab_history",
        "order": 1,
        "width": "12"
    },
    {
        "id": "group_charts",
        "type": "ui_group",
        "name": "Statistics",
        "tab": "tab_report",
        "order": 1,
        "width": "12"
    },
    {
        "id": "mqtt_in_status",
        "type": "mqtt in",
        "z": "flow1",
        "name": "",
        "topic": "bottle/status",
        "qos": "2",
        "broker": "hivemq_cloud",
        "wires": [["json_parse_status"]]
    },
    {
        "id": "mqtt_in_result",
        "type": "mqtt in",
        "z": "flow1",
        "name": "",
        "topic": "bottle/result",
        "qos": "2",
        "broker": "hivemq_cloud",
        "wires": [["json_parse_result"]]
    },
    {
        "id": "mqtt_out_control",
        "type": "mqtt out",
        "z": "flow1",
        "name": "",
        "topic": "bottle/control",
        "qos": "1",
        "broker": "hivemq_cloud",
        "wires": []
    },
    {
        "id": "json_parse_status",
        "type": "json",
        "z": "flow1",
        "wires": [["status_function", "chart_function"]]
    },
    {
        "id": "json_parse_result",
        "type": "json",
        "z": "flow1",
        "wires": [["history_function"]]
    },
    {
        "id": "sw_mode",
        "type": "ui_switch",
        "z": "flow1",
        "name": "Mode Switch",
        "label": "Mode (Manual / Auto)",
        "group": "group_main",
        "order": 1,
        "width": 0,
        "height": 0,
        "passthru": true,
        "decouple": "false",
        "topic": "mode",
        "style": "",
        "onvalue": "auto",
        "onvalueType": "str",
        "onicon": "",
        "oncolor": "",
        "offvalue": "manual",
        "offvalueType": "str",
        "officon": "",
        "offcolor": "",
        "wires": [["control_function"]]
    },
    {
        "id": "btn_start",
        "type": "ui_button",
        "z": "flow1",
        "name": "",
        "group": "group_main",
        "order": 2,
        "width": 3,
        "height": 1,
        "passthru": false,
        "label": "START",
        "tooltip": "",
        "color": "black",
        "bgcolor": "#00ff00",
        "icon": "play",
        "payload": "start",
        "payloadType": "str",
        "topic": "command",
        "wires": [["control_function"]]
    },
    {
        "id": "btn_stop",
        "type": "ui_button",
        "z": "flow1",
        "name": "",
        "group": "group_main",
        "order": 3,
        "width": 3,
        "height": 1,
        "passthru": false,
        "label": "STOP",
        "tooltip": "",
        "color": "white",
        "bgcolor": "red",
        "icon": "stop",
        "payload": "stop",
        "payloadType": "str",
        "topic": "command",
        "wires": [["control_function"]]
    },
    {
        "id": "control_function",
        "type": "function",
        "z": "flow1",
        "name": "Format Control",
        "func": "var msgOut = {};\nif (msg.topic === 'mode') {\n    msgOut.payload = JSON.stringify({ \"mode\": msg.payload });\n} else if (msg.topic === 'command') {\n    msgOut.payload = JSON.stringify({ \"command\": msg.payload });\n}\nreturn msgOut;",
        "outputs": 1,
        "wires": [["mqtt_out_control"]]
    },
    {
        "id": "txt_status",
        "type": "ui_text",
        "z": "flow1",
        "group": "group_status",
        "order": 1,
        "width": 0,
        "height": 0,
        "name": "",
        "label": "Current State",
        "format": "{{msg.payload}}",
        "layout": "row-spread",
        "wires": []
    },
    {
        "id": "led_conveyor",
        "type": "ui_text",
        "z": "flow1",
        "group": "group_status",
        "order": 2,
        "width": 0,
        "height": 0,
        "name": "",
        "label": "Conveyor",
        "format": "{{msg.payload}}",
        "layout": "row-spread",
        "wires": []
    },
    {
        "id": "status_function",
        "type": "function",
        "z": "flow1",
        "name": "Parse Status",
        "func": "var mode = msg.payload.mode;\nvar running = msg.payload.running;\nvar conveyor = msg.payload.conveyor;\n\nvar statusMsg = { payload: \"Mode: \" + mode.toUpperCase() + \" | \" + (running ? \"RUNNING\" : \"IDLE\") };\nvar conveyorMsg = { payload: conveyor ? \"ON\" : \"OFF\" };\n\nreturn [statusMsg, conveyorMsg];",
        "outputs": 2,
        "wires": [["txt_status"], ["led_conveyor"]]
    },
    {
        "id": "history_function",
        "type": "function",
        "z": "flow1",
        "name": "Format History",
        "func": "var result = msg.payload;\nvar d = new Date(result.timestamp * 1000);\nvar timeStr = d.toLocaleTimeString();\nvar classMap = {0: \"Correct\", 1: \"Misaligned\", 2: \"No Label\"};\nvar className = classMap[result.class_id] || \"Unknown\";\n\nvar html = `<tr><td>${timeStr}</td><td>${className}</td><td>${(result.confidence*100).toFixed(1)}%</td></tr>`;\n\n// We need to maintain state, but function nodes are stateless unless using context.\n// For simplicity, we just output the latest line to a text log or template.\n// A real history needs a context array.\n\nvar contextHist = flow.get('history') || [];\ncontextHist.unshift({time: timeStr, class: className, conf: (result.confidence*100).toFixed(1)});\nif (contextHist.length > 10) contextHist.pop();\nflow.set('history', contextHist);\n\nmsg.payload = contextHist;\nreturn msg;",
        "outputs": 1,
        "wires": [["ui_history_table"]]
    },
    {
        "id": "ui_history_table",
        "type": "ui_template",
        "z": "flow1",
        "group": "group_history",
        "name": "History Table",
        "order": 1,
        "width": "12",
        "height": "6",
        "format": "<table style=\"width:100%; text-align:left;\">\n  <tr><th>Time</th><th>Result</th><th>Confidence</th></tr>\n  <tr ng-repeat=\"row in msg.payload\">\n    <td>{{row.time}}</td>\n    <td>{{row.class}}</td>\n    <td>{{row.conf}}%</td>\n  </tr>\n</table>",
        "storeOutMessages": true,
        "fwdInMessages": true,
        "resendOnRefresh": true,
        "templateScope": "local",
        "wires": [[]]
    },
    {
        "id": "chart_function",
        "type": "function",
        "z": "flow1",
        "name": "Format Chart",
        "func": "var stats = msg.payload.stats;\nif (!stats) return null;\n\nvar data = [\n    { \"series\": [\"Correct\"], \"data\": [[stats.correct]], \"labels\": [\"Correct\"] },\n    { \"series\": [\"Misaligned\"], \"data\": [[stats.misaligned]], \"labels\": [\"Misaligned\"] },\n    { \"series\": [\"No Label\"], \"data\": [[stats.no_label]], \"labels\": [\"No Label\"] }\n];\n\n// Pie chart expects [val1, val2, val3] and labels\nvar pieMsg = {\n    payload: [stats.correct, stats.misaligned, stats.no_label],\n    labels: [\"Correct\", \"Misaligned\", \"No Label\"]\n};\n\nreturn pieMsg;",
        "outputs": 1,
        "wires": [["ui_chart_pie"]]
    },
    {
        "id": "ui_chart_pie",
        "type": "ui_chart",
        "z": "flow1",
        "name": "Classification Stats",
        "group": "group_charts",
        "order": 1,
        "width": 0,
        "height": 0,
        "label": "Results Distribution",
        "chartType": "pie",
        "legend": "true",
        "xformat": "HH:mm:ss",
        "interpolate": "linear",
        "nodata": "",
        "dot": false,
        "ymin": "",
        "ymax": "",
        "removeOlder": 1,
        "removeOlderPoints": "",
        "removeOlderUnit": "3600",
        "cutout": 0,
        "useOneColor": false,
        "useUTC": false,
        "colors": ["#00ff00", "#ff9900", "#ff0000", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5"],
        "outputs": 1,
        "useDifferentColor": false,
        "wires": [[]]
    },
    {
        "id": "hivemq_cloud",
        "type": "mqtt-broker",
        "name": "HiveMQ Cloud",
        "broker": "00abc31a42b94a7ea56216cf0b5b956d.s1.eu.hivemq.cloud",
        "port": "8883",
        "tls": "tls_config",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willPayload": "",
        "willMsg": {},
        "sessionExpiry": ""
    },
    {
        "id": "tls_config",
        "type": "tls-config",
        "name": "HiveMQ TLS",
        "cert": "",
        "key": "",
        "ca": "",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "00abc31a42b94a7ea56216cf0b5b956d.s1.eu.hivemq.cloud",
        "verifyservercert": true,
        "alpnprotocol": ""
    }
]
